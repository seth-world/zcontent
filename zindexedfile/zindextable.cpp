#include "zindextable.h"

#include <zcontent/zindexedfile/zindexfile.h>

#include <zxml/zxmlprimitives.h>

using namespace zbs;


ZIndexTable::ZIndexTable()
{

}

//------------ZIndexTable-------------------


long ZIndexTable::pop (void)
{
  if (size()<0)
  {
    return  -1;// Beware return  is multiple instructions in debug mode
  }
  last()->closeIndexFile();
  last()->~ZRawIndexFile();
  if (last()!=nullptr)
  {
    delete last();
    last()=nullptr;
  }
  return  _Base::pop();
} // pop

long ZIndexTable::erase (long pRank)
{
  if (pRank>lastIdx()) {
    return  -1;
  }
  Tab[pRank]->~ZRawIndexFile();

  if (Tab[pRank]!=nullptr)
    delete Tab[pRank];   // appearingly it puts the mess
  Tab[pRank]=nullptr; // just in case for avoiding double free
  return  _Base::erase(pRank);
} // erase

long ZIndexTable::insert (ZRawIndexFile *pIndexFile, long pRank)
{
  if (pRank > lastIdx()) {
    return  -1;
  }

  return _Base::insert(pIndexFile,pRank);
} // erase

void ZIndexTable::clear(void)
{
  while (size()>0)
    pop();
  _Base::clear();
}// clear


long ZIndexTable::searchIndexByName (const char* pName)
{
  for (long wi =0;wi<size();wi++)
  {
    if (Tab[wi]->IndexName==pName)
      return  wi;
  }

  return -1;
}//zsearchIndexByName

long ZIndexTable::searchCaseIndexByName (const char* pName)
{
  for (long wi =0;wi<size();wi++)
  {
    if (Tab[wi]->IndexName.isEqualCase((const utf8_t*)pName))
    {
      return  wi;
    }
  }

  return -1;
}//zsearchIndexByName

long ZIndexTable::searchIndexByName (const utf8String& pName)
{
  for (long wi =0;wi<size();wi++)
  {
    if (Tab[wi]->IndexName==pName)
      return  wi;
  }

  return -1;
}//zsearchIndexByName

long ZIndexTable::searchCaseIndexByName (const utf8String& pName)
{
  for (long wi =0;wi<size();wi++)
  {
    if (Tab[wi]->IndexName.isEqualCase(pName))
    {
      return  wi;
    }
  }

  return -1;
}//zsearchIndexByName

//------------------End ZIndexObjectTable ---------------------

//----------------XML---------------------------------------

/*
  <indextable>
    <index>
      <indexcontrolblock> <!-- no dictionary in index control block -->
          <indexname> </indexname>
          <keyuniversalsize> </keyuniversalsize>
          <duplicates> </duplicates>
      </indexcontrolblock>
      <file> <!-- from ZIndexTable >
         <zfiledescriptor>
            <URIContent>/home/gerard/testindexedpictures.zmf</URIContent>
            <URIHeader>/home/gerard/testindexedpictures.zrh</URIHeader> <!-- not modifiable generated by ZRandomFile-->
            <URIDirectoryPath>/home/gerard/</URIDirectoryPath> <!-- not modifiable generated by ZRandomFile-->
            <ZHeaderControlBlock> <!-- not modifiable -->
                <FileType>ZFT_ZSMasterFile</FileType>  <!-- do not modify : could cause data loss  see documentation-->
                <ZRFVersion>2000</ZRFVersion> <!-- not modifiable -->
                <OffsetFCB>4698</OffsetFCB> <!-- not modifiable -->
                <OffsetReserved>64</OffsetReserved> <!-- not modifiable -->
                <SizeReserved>4634</SizeReserved> <!-- not modifiable -->
            </ZHeaderControlBlock>
         <zfilecontrolblock>
            <AllocatedBlocks>15</AllocatedBlocks> <!-- not modifiable -->
            <BlockExtentQuota>5</BlockExtentQuota>ZSKeyDictionary
            <InitialSize>100000</InitialSize>
            <BlockTargetSize>1</BlockTargetSize>
            <HighwaterMarking>false</HighwaterMarking>
            <GrabFreeSpace>true</GrabFreeSpace>
         </zfilecontrolblock>
        </zfiledescriptor>
      </file>
    </index>
  </indextable>
*/

utf8String ZIndexTable::toXml(int pLevel,bool pComment)
{
  int wLevel=pLevel+1;
  utf8String wReturn;
  wReturn = fmtXMLnode("indextable",pLevel);
  if (pComment)
    fmtXMLaddInlineComment(wReturn," no dictionary in index control block");

  for (long wi=0;wi<count();wi++)
  {
    Tab[wi]->toXml(wLevel+1,pComment);
  }
  wReturn += fmtXMLendnode("indextable",pLevel);
  return wReturn;
} // toXml
