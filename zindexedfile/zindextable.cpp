#include "zindextable.h"

#include <zcontent/zindexedfile/zrawindexfile.h>

#include <zxml/zxmlprimitives.h>

using namespace zbs;


ZIndexTable::ZIndexTable()
{

}

//------------ZIndexTable-------------------


ZRawIndexFile*
ZIndexTable::operator [] (int wI) {
    if (count()==0) {
        ZException.setMessage("IndexFile::operator[]",ZS_OUTBOUNDHIGH,Severity_Fatal,
                              "Trying to access key index rank %d while no index key has been defined",
                              wI,count()-1);
        ZException.exit_abort();
    }
    if (wI >= count()) {
        ZException.setMessage("IndexFile::operator[]",ZS_OUTBOUNDHIGH,Severity_Fatal,
                              "Trying to access key index rank %d while maximum index rank is %d",
                              wI,count()-1);
        ZException.exit_abort();
    }
    return _Base::at(wI);
}

long ZIndexTable::pop (void)
{
  if (size()<0)
  {
    return  -1;// Beware return  is multiple instructions in debug mode
  }
  last()->closeIndexFile();
  last()->~ZRawIndexFile();
  if (last()!=nullptr)
  {
    _Base::pop();
//    delete last();
//    last()=nullptr;
  }
  return  _Base::pop();
} // pop

long ZIndexTable::erase (long pRank)
{
  if (pRank>lastIdx()) {
    return  -1;
  }
  Tab(pRank)->~ZRawIndexFile();

  if (Tab(pRank)!=nullptr)
    delete Tab(pRank);   // appearingly it puts the mess
  Tab(pRank)=nullptr; // just in case for avoiding double free
  return  _Base::erase(pRank);
} // erase



void ZIndexTable::clear(void)
{
  while (size()>0)
    delete popR();
  _Base::clear();
}// clear


long ZIndexTable::searchIndexByName (const char* pName)
{
  for (long wi =0;wi<size();wi++)
  {
    if (Tab(wi)->IndexName==pName)
      return  wi;
  }

  return -1;
}//zsearchIndexByName

long ZIndexTable::searchCaseIndexByName (const char* pName)
{
  for (long wi =0;wi<size();wi++)
  {
    if (Tab(wi)->IndexName.isEqualCase((const utf8_t*)pName))
    {
      return  wi;
    }
  }

  return -1;
}//zsearchIndexByName

long ZIndexTable::searchIndexByName (const utf8String& pName)
{
  for (long wi =0;wi<size();wi++)
  {
    if (Tab(wi)->IndexName==pName)
      return  wi;
  }

  return -1;
}//zsearchIndexByName

long ZIndexTable::searchCaseIndexByName (const utf8String& pName)
{
  for (long wi =0;wi<size();wi++)
  {
    if (Tab(wi)->IndexName.isEqualCase(pName))
    {
      return  wi;
    }
  }

  return -1;
}//zsearchIndexByName


long ZIndexTable::push(ZRawIndexFile* pIn){
  if (searchIndexByName(pIn->IndexName) < 0){  /* if index name not found -> OK can create */
    return _Base::push(pIn);
  }
  ZException.setMessage("ZIndexTable::push",ZS_DUPVIOLATION,Severity_Error,
      "Index name <%s> already exists within index table.",pIn->IndexName.toString());
  return -1;
}

long ZIndexTable::insert (ZRawIndexFile *pIn, long pRank)
{
  if (pRank > lastIdx()) {
    ZException.setMessage("ZIndexTable::insert",ZS_OUTBOUNDHIGH,Severity_Error,
        "Index rank <%ld> for inserting index name <%s> is out of index table boundaries [0,%ld].",pRank,pIn->IndexName.toString(),lastIdx());
    return  -1;
  }
  if (searchIndexByName(pIn->IndexName) < -1) {
    ZException.setMessage("ZIndexTable::insert",ZS_DUPVIOLATION,Severity_Error,
        "Index name <%s> already exists within index table.",pIn->IndexName.toString());
        return  -1;
  }
  return _Base::insert(pIn,pRank);
} // insert
//------------------End ZIndexObjectTable ---------------------

//----------------XML---------------------------------------

/*
  <indextable>
    <index>
      <indexcontrolblock> <!-- no dictionary in index control block -->
          <indexname> </indexname>
          <keyguessedsize> </keyguessedsize>
          <duplicates> </duplicates>
      </indexcontrolblock>
      <file> <!-- from ZIndexTable >
         <zfiledescriptor>
            <URIContent>/home/gerard/testindexedpictures.zmf</URIContent>
            <URIHeader>/home/gerard/testindexedpictures.zrh</URIHeader> <!-- not modifiable generated by ZRandomFile-->
            <URIDirectoryPath>/home/gerard/</URIDirectoryPath> <!-- not modifiable generated by ZRandomFile-->
            <ZHeaderControlBlock> <!-- not modifiable -->
                <FileType>ZFT_ZSMasterFile</FileType>  <!-- do not modify : could cause data loss  see documentation-->
                <ZRFVersion>2000</ZRFVersion> <!-- not modifiable -->
                <OffsetFCB>4698</OffsetFCB> <!-- not modifiable -->
                <OffsetReserved>64</OffsetReserved> <!-- not modifiable -->
                <SizeReserved>4634</SizeReserved> <!-- not modifiable -->
            </ZHeaderControlBlock>
         <zfilecontrolblock>
            <AllocatedBlocks>15</AllocatedBlocks> <!-- not modifiable -->
            <BlockExtentQuota>5</BlockExtentQuota>ZSKeyDictionary
            <InitialSize>100000</InitialSize>
            <BlockTargetSize>1</BlockTargetSize>
            <HighwaterMarking>false</HighwaterMarking>
            <GrabFreeSpace>true</GrabFreeSpace>
         </zfilecontrolblock>
        </zfiledescriptor>
      </file>
    </index>
  </indextable>
*/

utf8String ZIndexTable::toXml(int pLevel,bool pComment)
{
  int wLevel=pLevel+1;
  utf8String wReturn;
  wReturn = fmtXMLnode("indextable",pLevel);
  if (pComment)
    fmtXMLaddInlineComment(wReturn," no dictionary in index control block");

  for (long wi=0;wi<count();wi++)
  {
    Tab(wi)->toXml(wLevel+1,pComment);
  }
  wReturn += fmtXMLendnode("indextable",pLevel);
  return wReturn;
} // toXml
