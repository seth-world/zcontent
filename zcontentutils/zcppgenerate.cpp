#include "zcppgenerate.h"

#include <zxml/zxmlprimitives.h>
#include <zexceptiondlg.h>

#include <zindexedfile/zdictionaryfile.h>
#include <zcppparser/zcppparser.h>


using namespace zbs;

const char* wHHeader=
    "/** this file has been generated by zcontent utilities generator \n"
    " from dictionary file %s\n"
    " generation date %s\n"
    " */\n\n"

    "#ifndef %s_H\n"
    "#define %s_H\n\n"

    "#include <sys/types.h>\n"
    "#include <ztoolset/zlimit.h>\n"
    "#include <ztoolset/ztypetype.h>\n"
    ;

const char* wHClass=
    "\n/** @brief %s %s"
    " */\n"

    "#pragma pack(push)\n"
    "#pragma pack(1)         // memory alignment on byte\n"
    "\n"
    "class %s {\n"
    "private:\n"
    "   ZBitset     FieldPresence;\n"
    "   uint32_t    StartSign=cst_ZMSTART;;\n"
    "   uint16_t    EndianCheck=cst_EndianCheck_Normal;;\n"
    "public:\n"
    "/* Public attributes */\n";


const char* wHMethods =
    "/* Public methods */\n"
    "   %s()=default;\n"
    "   %s& _copyFrom(const %s& pIn);\n"
    "   %s& operator = (const %s& pIn) { return _copyFrom(pIn); }\n"
    "   void setFromPtr(const unsigned char *&pPtrIn);\n"
    "   void set(const %s& pIn);\n"
    "   void _convert();\n"
    "   void serialize();\n"
    "   void deserialize();\n"
    "   bool isReversed();\n"
    "   bool isNotReversed(); \n"
    "}; // %s \n";

const char* wHEndClass =
    "#pragma pack(pop)\n"
    "#endif //%s_H\n";


const char* wCppHeader =
    "#include \"%s\"\n"
    "#include <ztoolset/zatomicconvert.h>\n\n"
    "   bool %s::isReversed() {\n"
    "     if (EndianCheck==cst_EndianCheck_Reversed) return true;\n"
    "     return false;\n"
    "   }\n"
    "   bool %s::isNotReversed() { \n"
    "     if (EndianCheck==cst_EndianCheck_Normal) return true;\n"
    "     return false;\n"
    "   }\n"
    ;

const char* wSCopyFromBegin =
    "   %s& %s::_copyFrom(const %s& pIn) {\n"
    "     StartSign = pIn.StartSign ;\n"
    "     EndianCheck = pIn.EndianCheck ;\n"
    ;
const char* wSCopyFromLine =
    "     %s = pIn.%s ;\n";

const char* wSMethodEnd =
    " }\n" ;


const char* wCppDeserialize1 =
    "void %s::_convert() {\n"
    "  if (is_big_endian()) \n"
    "     return ;\n"
    " /* StartSign EndSign(palyndromas) do not need to be reversed */ "

    "   if (isNotReversed()) { \n"
    "       fprintf (stderr,\"%s::deserialize-W-ALRDY object <%s> already deserialized. \n\");\n"
    "       return;\n"
    "   }\n" ;

const char* wCppSerialize =
    "void %s::_serialize() {\n"
    "  if (is_big_endian()) \n"
    "     return ;\n"
    " /* StartSign EndSign(palyndromas) do not need to be reversed */ "
    "   if (isReversed()) { \n"
    "       fprintf (stderr,\"%s::serialize-W-ALRDY object <%s> already serialized. \n\");\n"
    "       return;\n"
    "   }\n" ;




ZCppGenerate::ZCppGenerate(ZDictionaryFile *pDictionaryFile)
{
  DictionaryFile = pDictionaryFile;
}


utf8VaryingString
ZCppGenerate::genCopyFrom(utf8VaryingString& pClassName) {
  utf8VaryingString wReturn;
  wReturn.sprintf(wSCopyFromBegin,pClassName.toCChar(),pClassName.toCChar(),pClassName.toCChar());

  for (long wi=0 ; wi < DictionaryFile->count(); wi++) {
    wReturn.addsprintf(wSCopyFromLine,
        DictionaryFile->Tab[wi].getName().toString(),DictionaryFile->Tab[wi].getName().toString());
  }
  wReturn += wSMethodEnd ;
  return wReturn;
} // genCopyFrom



utf8VaryingString
ZCppGenerate::genIncludes(ZTypeBase pType,
    ZArray<GenObj> &pGenObjList,
    ZArray<GenInclude> &pGenIncludeList) {

  utf8VaryingString wFileInclude;
  /* search for include files when classes */

  //  if ((pType & ZType_Class) ||(pType == ZType_bitset)){ /* classes have an include file associated to it */
  if (pType & (ZType_Class | ZType_ByteSeq) ) { /* classes have an include file associated to it */
    for (long wR=0; wR < pGenObjList.count();wR++) {
      if (pGenObjList[wR].ZType == (pType & ~(ZType_Pointer | ZType_Array)) ) {
        if (!pGenIncludeList[pGenObjList[wR].IncludeRank].Used) {
          wFileInclude.sprintf("#include <%s>\n",
              pGenIncludeList[pGenObjList[wR].IncludeRank].Include.toString());
          pGenIncludeList[pGenObjList[wR].IncludeRank].Used=true;
        }
        return wFileInclude;
      }
    }// for (long wR=0; wR < pGenObjList.count();wi++)
  } // if (DictionaryFile->Tab[wi].ZType & ZType_Class)

  return utf8VaryingString("");
} //genIncludes


utf8VaryingString
ZCppGenerate::genHeaderFields(utf8VaryingString& pFileIncludeList,
    ZArray<GenObj> &pGenObjList,
    ZArray<GenInclude> &pGenIncludeList) {

  utf8VaryingString wReturn , wSingleVar;


  for (long wi=0 ; wi < DictionaryFile->count(); wi++) {

    wSingleVar = ZTypeToCType(DictionaryFile->Tab[wi].ZType,
        DictionaryFile->Tab[wi].Capacity,
        DictionaryFile->Tab[wi].getName());
    wReturn += "    ";
    wReturn += wSingleVar;
    wReturn += ";\n";

    /* search for include files when classes */

    pFileIncludeList += genIncludes(DictionaryFile->Tab[wi].ZType,pGenObjList,pGenIncludeList);
  }

  return wReturn;
}//genHeaderFields


/*
<?xml version='1.0' encoding='UTF-8'?>
 <zcppgenerate version = "'0.30-0'">
     <includefiles>
        <object>
            <ztype>ZType_Utf8FixedString</type>
            <file>ztoolset/utffixedstring.h</file>
         </object>
    </includefiles>
  </zcppgenerate>
*/

ZStatus
ZCppGenerate::loadGenerateParameters(const uriString& pXmlFile,ZaiErrors *pErrorLog) {
  ZStatus wSt;
  const char* wWDParam=getenv(__PARSER_PARAM_DIRECTORY__);
  if (!wWDParam)
    wWDParam="";
  const char* wWDWork=getenv(__PARSER_WORK_DIRECTORY__);
  if (!wWDWork)
    wWDWork="";

  uriString wXmlGenParamsFile;
  if (pXmlFile.isEmpty()) {
    wXmlGenParamsFile = wWDParam;
    wXmlGenParamsFile.addConditionalDirectoryDelimiter();
    wXmlGenParamsFile += __GENERATE_PARAMETER_FILE__;
  }
  wSt=loadXmlParameters(wXmlGenParamsFile,wGenObjList,wGenIncludeList,pErrorLog);
  if (wSt!=ZS_SUCCESS) {
    std::cout.flush();
    ZExceptionDLg::displayLast("Load parameters file",false);
  }
  return wSt;
}//loadGenerateParameters


ZStatus
ZCppGenerate::loadXmlParameters(const uriString& pXmlFile,
                                ZArray<GenObj> &pGenObjList,
                                ZArray<GenInclude> &pGenIncludeList,
                                ZaiErrors* pErrorLog) {


  utf8VaryingString wXmlString;

  ZStatus wSt;
  pErrorLog->setAutoPrintOn(ZAIES_Text);

  if (!pXmlFile.exists())  {
    ZException.setMessage("ZCppParser::loadXmlParserRules",ZS_FILENOTEXIST,Severity_Error,"Parameter file <%s> has not been found.",pXmlFile.toCChar());
    pErrorLog->errorLog("ZCppParser::loadXmlParserRules-E-FILNFND Parameter file <%s> has not been found.",pXmlFile.toCChar());
    return ZS_FILENOTEXIST;
  }


  if ((wSt=pXmlFile.loadUtf8(wXmlString))!=ZS_SUCCESS) {
    pErrorLog->logZException();
    return wSt;
  }

  zxmlDoc     *wDoc = nullptr;
  zxmlElement *wRoot = nullptr;
  zxmlElement *wParamRootNode=nullptr;
  zxmlElement *wincludeNode=nullptr;
  zxmlElement *wObjectNode=nullptr;
  zxmlElement *wSwapNode=nullptr;

  zxmlElement *wTypeNode=nullptr;
  zxmlElement *wIncludeFileNode=nullptr;

  utf8VaryingString wKeyword;

  ZTypeBase             wZType;

  utf8VaryingString     wIncludeFile;


  int wErrored=0,wWarned=0;

  wDoc = new zxmlDoc;
  wSt = wDoc->ParseXMLDocFromMemory(wXmlString.toCChar(), wXmlString.getUnitCount(), nullptr, 0);
  if (wSt != ZS_SUCCESS) {
    pErrorLog->logZException();
    pErrorLog->errorLog(
        "DicEdit::loadGenerateParameters-E-PARSERR Xml parsing error for string <%s> ",
        wXmlString.subString(0, 25).toString());
    return wSt;
  }

  wSt = wDoc->getRootElement(wRoot);
  if (wSt != ZS_SUCCESS) {
    pErrorLog->logZException();
    return wSt;
  }
  if (!(wRoot->getName() == "zcppgenerate")) {
    ZException.setMessage("ZCppParser::loadXmlParserRules",
        ZS_XMLINVROOTNAME,
        Severity_Error,
        "Invalid root name <%s> - file <%s>.",wRoot->getName().toString(),pXmlFile.toCChar());
    pErrorLog->errorLog(
        "DicEdit::loadGenerateParameters-E-INVROOT Invalid root node name <%s> expected <zcppgenerate>",
        wRoot->getName().toString());
    return ZS_XMLINVROOTNAME;
  }

  /*------------------ Conversion table -----------------------*/

  while (true) {
    wSt=wRoot->getChildByName((zxmlNode*&)wIncludeFileNode,"includefiles");
    if (wSt!=ZS_SUCCESS) {
      pErrorLog->logZStatus(
          ZAIES_Error,
          wSt,
          "DicEdit::loadGenerateParameters-E-CNTFINDND Error cannot find node element with name <%s> status <%s>",
          "includefiles",
          decode_ZStatus(wSt));
      break;
    }

    wSt=wIncludeFileNode->getFirstChild((zxmlNode*&)wObjectNode);

    while (wSt==ZS_SUCCESS) {
      if (wObjectNode->getName()=="object") {

        wSt=XMLgetChildText( wObjectNode,"ztype",wKeyword,pErrorLog);
        wZType = encode_ZType(wKeyword);

        wSt=XMLgetChildText( wObjectNode,"file",wIncludeFile,pErrorLog);
        long wIncludeRank=0;
        for (;wIncludeRank < pGenIncludeList.count();wIncludeRank++) {
          if (pGenIncludeList[wIncludeRank].Include ==  wIncludeFile ) {
            break;
          }
        }
        if (wIncludeRank==pGenIncludeList.count()) {
          wIncludeRank = pGenIncludeList.push(GenInclude(wIncludeFile));
        }

        pGenObjList.push(GenObj(wZType,wIncludeRank));
      }//if (wObjectNode->getName()=="object")
      wSt=wObjectNode->getNextNode((zxmlNode*&)wSwapNode);
      XMLderegister(wObjectNode);
      wObjectNode=wSwapNode;
    }//while (wSt==ZS_SUCCESS)

    pErrorLog->textLog("_________________Generation parameters load report____________________\n"
                     " %ld object types %ld include files.\n", pGenObjList.count(),pGenIncludeList.count());
    pErrorLog->textLog("     Object types\n");

    for (long wi=0;wi<pGenObjList.count();wi++) {
      pErrorLog->textLog("%3ld- <%25s> <%s>\n",wi,
          decode_ZType( pGenObjList[wi].ZType),
          pGenObjList[wi].IncludeRank < 0?"***MISS INCLUDE***":pGenIncludeList[pGenObjList[wi].IncludeRank].Include.toCChar()
          );
    }
    pErrorLog->textLog("     include file definitions \n");
    for (long wi=0;wi<pGenIncludeList.count();wi++) {
      pErrorLog->textLog("%3ld- <%25s>\n",wi,
          pGenIncludeList[wi].Include.toString()
          );
    }
    pErrorLog->textLog("________________________________________________________________\n");
    XMLderegister(wObjectNode);
    XMLderegister(wIncludeFileNode);
    XMLderegister(wRoot);
    break;
  } // while (true)


  XMLderegister((zxmlNode *&) wParamRootNode);
  if (wSt==ZS_EOF)
    return ZS_SUCCESS;
  return wSt;


}// loadGenerateParameters

ZStatus
ZCppGenerate::generateInterface(const utf8VaryingString& pOutName,const utf8VaryingString& pClassName,const utf8VaryingString& pBrief ) {
  ZStatus wSt=ZS_SUCCESS;

  uriString wHFile  , wCppFile ;

  if (pOutName.isEmpty()){
    wHFile  = pClassName;
    wCppFile = pClassName;
  }
  else {
    wHFile  = pOutName;
    wCppFile = pOutName;
  }

  utf8VaryingString wHContent,wFieldsContent, wIncludeContent, wCppContent  ;
  utf8VaryingString wClassUpper = pClassName.toUpper().toString();
  utf8VaryingString wClassLower = pClassName.toLower().toString();


  utf8VaryingString wBase= wClassLower;

  const char* wWDWork=getenv(__PARSER_WORK_DIRECTORY__);
  if (!wWDWork)
    wWDWork="";

  if (GenPath.isEmpty()) {
    wHFile = wHFile.getDirectoryPath();
    if (wHFile.isEmpty()) {
      wHFile = wWDWork;
    }
  }
  wHFile.addConditionalDirectoryDelimiter();
  wHFile += wBase ;

  wCppFile=wHFile;
  wHFile += ".h";
  wCppFile += ".cpp";

  /* Code generation */

  wHContent.sprintf(wHHeader,
      DictionaryFile->getURIContent().toString(),
      ZDateFull::currentDateTime().toFormatted().toString(),
      wClassUpper.toString(),
      wClassUpper.toString());

  /* add bitset as default include file */

  wIncludeContent += "/*      private include files        */\n";
  wIncludeContent += genIncludes(ZType_bitset,wGenObjList,wGenIncludeList);
  wIncludeContent += "/*      local include files          */\n";

  wFieldsContent += genHeaderFields(wIncludeContent,wGenObjList,wGenIncludeList);

  wHContent += wIncludeContent;

  wHContent.addsprintf(wHClass,
      pClassName.toCChar(),
      pBrief.toString(),
      pClassName.toCChar());


  wHContent += wFieldsContent;

  wHContent.addsprintf(wHMethods,
      pClassName.toCChar(),
      pClassName.toCChar(),
      pClassName.toCChar(),
      pClassName.toCChar(),
      pClassName.toCChar(),
      pClassName.toCChar(),
      pClassName.toCChar());


  wHContent.addsprintf(wHEndClass,wClassUpper.toString());


  wSt=wHFile.writeContent(wHContent);
  if (wSt!=ZS_SUCCESS) {
    ZExceptionDLg::displayLast("Write header file",false);
    return wSt;
  }


  /* cpp file generation */

  wCppContent.sprintf(wCppHeader,wHFile.toString(), pClassName.toCChar(),pClassName.toCChar());

  /* _copyFrom expanded method */
  wCppContent.addsprintf(wSCopyFromBegin,pClassName.toCChar(),pClassName.toCChar(),pClassName.toCChar());
  for (long wi=0 ; wi < DictionaryFile->count(); wi++) {
    wCppContent.addsprintf(wSCopyFromLine, DictionaryFile->Tab[wi].getName().toString(),DictionaryFile->Tab[wi].getName().toString());
  }
  wCppContent += wSMethodEnd;



  wSt=wCppFile.writeContent(wCppContent);
  if (wSt!=ZS_SUCCESS) {
    ZExceptionDLg::displayLast("Write cpp file",false);
    return wSt;
  }
  return ZS_SUCCESS;
}
